% !TeX root = ../../pythonTutorial.tex
\section{Grundlegende Testmöglichkeiten}
\label{testing:sec:grundlegendeTestmoeglichkeiten}
Zum Testen unter Python gibt es mehrere Module, die das Testen unterstützen.
Zum einen das Modul \lstinline$doctest$, welches als interaktive Dokumentation Testmuster bereitstellt.
Zum anderen das Modul \lstinline$unittest$, welches den Unittests unter Java mit JUnit sehr ähnelt.
Beide Module ermöglichen Regressionstests.
\subsection{doctest}
\label{testing:sec:DocTest}
Das Modul \lstinline$doctest$ ermöglicht es, Tests parallel mit dem Programmcode in die selbe Datei zu schreiben.
Dies ist sowohl innerhalb von Funktionen als auch außerhalb möglich.
Hierbei werden die Tests in Kommentarblöcken (\lstinline$"""$) durch die Zeichenfolge \lstinline$>>>$ eingeleitet.
Danach wird die Funktion, die getestet werden soll, mit den gewünschten Testparametern aufgerufen.
Diesem folgt dann entweder das Ergebnis oder eine Fehlerbehandlung im Falle einer zu prüfenden Exception.

Das folgende Beispiel\randnotiz{Beispiel} zeigt, wie \lstinline$doctests$ in der Praxis Anwendung finden.
Die Tests werden, sobald der Programmcode ausgeführt wird, ebenfalls ausgeführt. 
Dadurch, das die Tests bei dem zu testenden Code stehen, wird ein direkter Bezug zwischen beiden hergestellt.
Sollte beim Ausführen kein Test fehlschlagen, kommt es zu keiner Ausgabe durch den Interpreter.
Ist trotzdem eine Ausgabe erwünscht, ist diese mit dem Parameter \lstinline$-v$ (verbose) aktivierbar.

\lstinputlisting[language=Python,lastline=37, label={tests:lst:SimpleDocTest}]{chapters/testing/src/simpleDocTest.py}

Im nachfolgenden Beispiel ist die Ausgabe der Tests aus dem oben gezeigten Codebeispiel zu sehen.
Der Ablauf der einzelnen Test ist jedes Mal gleich.
Zuerst wird der Test mit den Versuchsparametern ausgegeben und im Anschluss der Erwartungswert gezeigt.
Sollte der Rückgabewert der Funktion dem Erwartungswert entsprechen, wird der Test mit OK beendet.
Gleiches gilt beim Testen auf Exceptions. 
Zum Schluss werden die Ergebnisse in einer Auflistung zusammengefasst und nach Zugehörigkeit gruppiert.
Hierbei handelt es sich um einen freien Testfall sowie drei Testfälle innerhalb der Funktion.
Danach gibt es noch eine weitere Zusammenfassung, die die Tests nach Erfolg und Misserfolg gruppiert.
Dies soll dem Anwender ermöglichen, alle Tests mit einem Blick zu erfassen.

\lstinputlisting[language=python,linerange={1-3,40-69}, label={tests:lst:SimpleDocTestPrintSuccess}]{chapters/testing/src/simpleDocTest.py}

Um den Fehlerfall zu betrachten, wurde die Rückgabe der Funktion von \lstinline$x * y$ auf \lstinline$x + y$ geändert.
Dies sorgte sofort für zwei Fehler beim Start des Programms.
Die einzelnen Fehler werden getrennt dargestellt.
Im Unterschied zum Erfolgsfall wird hier die Stelle angegeben, an der der Test steht.
Zusätzlich dazu wird der zurückgegebene Wert angezeigt.
Am Ende erfolgt wieder eine Zusammenfassung.

\lstinputlisting[language=python,linerange={1-3,73-93}, label={tests:lst:SimpleDocTestPrintFailure}]{chapters/testing/src/simpleDocTest.py}

Über \randnotiz{Strukturierung} das Modul \lstinline$doctest$ ist es einerseits möglich, Tests direkt an den Programmcode zu hängen und über den Docstring der Funktion auszuführen.
Diese Tests werden am Ende eines Moduls mit \lstinline$doctest.testmod()$ aufgerufen.
Andererseits ist es möglich, über \lstinline$doctest.testfile()$ separate Testdateien als Tests auszuführen.
Es ist also möglich, Tests zu einer Modul oder einer Klasse außerhalb der Klasse zu definieren.
Damit der Python Interpreter weiß, welches Modul hierbei getestet werden soll, muss dies vorher über eine Importanweisung bekannt gemacht werden.
Da sich der Befehl in einem Docstring befindet, muss dieser wie die Funktionsaufrufe über \lstinline$>>>$ eingeleitet werden.
Bei dieser Art der Strukturierung ist es darüber hinaus auch möglich, die Tests unabhängig vom Programmcode ablaufen zu lassen.
Hierfür muss, wie im folgenden Listing zu sehen, das Modul \lstinline$doctest$ angegeben und die Testdatei aufgerufen werden.
Das Modul erkennt automatisch, dass es in diesem fall \lstinline$doctest.testfile()$ nutzen muss.
\begin{lstlisting}[label=testing:lst:AusfuehrenVonDoctests,language=bash]
    python -m doctest exampleTest.txt
\end{lstlisting}

Die Textdatei für ausgelagerte Testfälle kann die wie folgt aussehen:

\lstinputlisting[label={tests:lst:docTestExtern}]{chapters/testing/src/doctest.txt}

\tip{Grundsätzlich ist die Menge des Texts, der zusätzlich zum eigentlichen Test in einer ausgelagerten doctest-Datei steht, beliebig.
Zu beachten ist lediglich die Importanweisung sowie die Notation mit \lstinline$>>>$ zum Aufrufen der Funktion und deren Ausgabe im Anschluss.}

\subsection{unittest}
\label{testing:sec:UnitTest}
Das Modul \lstinline$unittest$ ermöglicht das Testen in separaten Klassen.
Es wurde in Anlehnung an JUnit erstellt.
Ziel ist es, dem Programmierer zu ermöglichen, kleine wiederholbare Tests zu schreiben.
Mit diesen Testfällen lässt sich Programmcode auf Integrations- und Operationsebene testen.


\subsubsection*{Beispieltest}
\label{testing:sec:BeispielTest} 

Zum Einstieg in das Thema Unittest, zunächst ein kleines Beispiel einer Testklasse.
\lstinputlisting[language=Python, label={testing:lst:BeispielTest}]{chapters/testing/src/simpleTest.py}

Um einen Test zu erstellen, muss die Klasse, in der die Testfälle definiert werden, von der Klasse \lstinline$unittest.TestCase$ ableiten.
Hierfür muss zuvor das Modul \lstinline$unittest$ importiert werden.
Anschließend können die einzelnen Testmethoden einleitend mit der Bezeichnung \textit{test} definiert werden.
Die einzelnen Testfälle werden parallel und ohne bestimmte Reihenfolge abgearbeitet.
Zusätzlich zu den einzelnen Testfällen existieren noch zwei weitere Methoden zu Ablaufsteuerung.
Die Methode \lstinline$setUp()$ sowie die Methode \lstinline$tearDown()$.
Diese beide Methoden erlauben das Ausführen von Code vor und nach jeder Testmethode.
Dies ermöglicht es, bestimmte Testvoraussetzungen vor jedem Test zu schaffen. 


\subsubsection*{Ausführen von Testzusammenstellungen}
\label{testing:sec:AusfuehrenVonTestzusammenstellungen}
Die erstellten Tests können nicht ohne Weiteres auf der Konsole ausgeführt werden.
Um das Testen zu starten, ist es notwendig, Python über den Parameter \lstinline$-m unittest$ aufzurufen.
Dies ist erforderlich, um das Modul Unittest im Skriptmodus zu starten.
Im Anschluss folgt das zu testende Objekt.
Dieses kann entweder mehrere Module, eine Klasse oder eine einzelne Methode umfassen.
Die Pythondatei selbst ist ebenfalls ein mögliches Testobjekt.
Hierbei werden nur die Testfälle in der Datei ausgeführt.

\begin{lstlisting}[label=testing:lst:AusfuehrenVonTestzusammenstellungen,language=bash]
python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method
python -m unittest tests/test_something.py
\end{lstlisting}

Grundsätzlich werden nach Ausführen des Befehls nur fehlerhafte Testfälle angezeigt.
Um eine ausführliche Ausgabe zu forcieren, wird der Parameter \lstinline$-v$ benötigt.
Dieser Parameter steht für \lstinline$verbose$ und sorgt dafür, dass erfolgreiche Testfälle ebenfalls eine Ausgabe produzieren.
Weitere Parameter hierzu können der Python Dokumentation \cite{pythondoku} entnommen werden.
Alternativ kann durch den Parameter \lstinline{-h} eine Liste der möglichen Parameter auf der Konsole ausgegeben werden.

\uebung
\aufgabe{testen01} 
\aufgabe{testen02} 
 
\subsection*{Zusammenfassung}
In diesem Kapitel wurde das Thema Testen grundlegend mit dem Modulen \lstinline$doctest$ sowie \lstinline$unittest$ gezeigt.
Nach Abschluss der zugehörigen Übungen sollte es dem Leser möglich sein, rudimentäre Tests über beide Module zu schreiben.
Dies sollte die testgetriebene Entwicklung weiteren Codes ermöglichen. 
Neben den hier behandelten grundlegenden Themen gibt es noch weiterführendes Material, welches der Python Dokumentation, entnommen werden kann.
