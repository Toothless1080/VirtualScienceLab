% !TeX root = ../../pythonTutorial.tex

\section{Kontrollstrukturen}
\label{kontrollstrukturen:sec:Kontrollstrukturen}

Die Kontrollstrukturen in Python haben einen formalen Unterschied zu Java oder C++, funktional allerdings sind sie identisch. In Python werden keine geschweiften Klammern genutzt, um die Blöcke der einzelnen Abfragen abzugrenzen. Dazu genügt das Einrücken der Anweisung. Dies gilt sowohl für Bedingungen und Conditional Expressions, als auch für Schleifen. Im Folgenden schauen wir uns die einzelnen Strukturen im Detail und mit Beispielen an.

\subsection{If-then-else}
\label{kontrollstrukturen:sec:ifthenelse}

Die if-then-else-Struktur ermöglicht es, wie wir es bereits kennen, simple wenn-dann Abfragen zu tätigen.\\
Mehrere Abfragemöglichkeiten werden mit elif markiert. Vergleich hierzu Listing \ref{kontrollstrukturen:lst:refif}.



\begin{lstlisting}[label=kontrollstrukturen:lst:refif]
# If-then-else
if statement1:
    print("Fall 1")
elif statement2:
    print("Fall 2")
else:
    print("Fall 3")
\end{lstlisting}

\textbf{Conditional Expressions}

Die Conditional Expressions (engl. bedingte Ausdrücke) stellen eine kompaktere Schreibweise als if-then-else-Bedinungen dar. Ein Beispiel ist in Listing \ref{kontrollstrukturen:lst:refcond} zu finden.

\begin{lstlisting}[label=kontrollstrukturen:lst:refcond]
# Conditional Expressions
# Klassisches If-Else
if wort == "start":
    x = "los"
else:
    x = halt"

# If-Else als Conditional Expression
x = ("los" if wort == "start" else "halt")

\end{lstlisting}


\subsection{Schleifen}
\label{kontrollstrukturen:sec:Schleifen}

Python hat sowohl bedingte, als auch Zähler-Schleifen, welche wir uns beide im Folgenden genauer ansehen werden (vgl. Listing \ref{kontrollstrukture:lst:refwhile} und \ref{kontrollstrukture:lst:reffor}). Schleifen bestehen aus einer Anweisung und einem Kontrollblock, welcher solange durchlaufen wird, bis die Anweisung oder ein Abbruchkriterium erfüllt wurde. Schleifen, die niemals ein Abbruchkriterium erfüllen und so endlos durchlaufen werden, heißen Endlosschleifen. Diese führen dazu, dass der Interpreter irgendwann aufgibt und abbricht.

\begin{lstlisting}[label=kontrollstrukturen:lst:refwhile]
# While-Schleife
while Bedingung:
    Anweisungsblock
    if Bedingung:
        Anweisungsblock
        continue
    if Bedingung:
        Anweisungsblock
        break
    Anweisungsblock

\end{lstlisting}


\begin{lstlisting}[label=kontrollstrukturen:lst:reffor]
# For-Schleife
for Variable in Objekt (von, bis, Variablenveränderung):
    Anweisungsblock
    if Bedingung:
        Anweisungsblock
        continue
    Anweisungsblock
    if Bedingung:
        Anweisungsblock
        break
    Anweisungsblock

\end{lstlisting}

Die while-Schleife erinnert stark an die Verwendung in anderen Programmiersprachen. Wird jedoch die for-Schleife betrachtet, fallen einige Unterschiede bei der Beschreibung der Anweisung auf. Die Variable wird einmalig am Anfang der Anweisung definiert. Anschließend wird die range, also die Grenzen von wo bis wo die Variable in der Schleife durchgegangen werden soll. Die beiden Grenzen werden mit einem Komma getrennt. Fügt man eine dritte Zahl dahinter ein, dient diese dazu die Variable bei jedem Durchgang der Schleife zu verändern. Lässt man diese Zahl weg, so wird die Variable bei jedem Schleifendurchlauf um eins erhöht. Schreibt man beispielsweise eine 3, wird die Variable jedes Mal, wenn die Schleife erneut durchgegangen wird um 3 erhöht.

Zur Veranschaulichung finden Sie im Folgenden zwei Beispiele zur Verwendung einer while- und einer for-Schleife. Beide Schleifen bilden die Summe der Zahlen von 1 bis 10.

\begin{lstlisting}[label=kontrollstrukturen:lst:bspwhile]
# Beispiel als While-Schleife

n = 10
s = 0
i = 1

while i <= n:
    s = s + i
    i = i + 1

print ("Summe:", s)

# Ausgabe: "Summe: 55"
\end{lstlisting}


\begin{lstlisting}[label=kontrollstrukturen:lst:bspfor]
# Beispiel als For-Schleife

s = 0

for i in range (0,11):
    s = s + i

print ("Summe: ", s)

# Ausgabe: "Summe: 55"
\end{lstlisting}

\subsection{Ausdrücke und Operatoren}
\label{grundlagen:sec:AusdrückeundOperationen}

Die meisten Operatoren für Zahlenwerte sind in Python ähnlich wie bei anderen Programmiersprachen. 
In Tabelle \ref{kontrollstrukturen:operators} wird eine Übersicht gegeben.

\begin{table}[h]
\centering
\caption{\label{kontrollstrukturen:operators}Ausdrücke und  Operatoren}
\begin{tabular}{|p{0.15\textwidth}|p{0.5\textwidth}|p{0.25\textwidth}|}
\hline
\multicolumn{1}{|c|}{\textbf{Operator}} & \multicolumn{1}{c|}{\textbf{Bezeichnung}} & \multicolumn{1}{c|}{\textbf{Beispiel}} \\ \hline
\hline
+, - & Addition, Subtraktion & 4 - 3 \\ \hline
*, \% & Multiplikation, Rest & 24 \% 5 \newline Ergebnis: 4 \\ \hline
/ & Division & 10 / 3 \newline Ergebnis: 3.33333333333335 \\ \hline
// & Ganzzahldivision & 10 // 3 \newline Ergebnis: 3 \\ \hline
+x, -x & Vorzeichen & -5 \\ \hline
** & Exponentiation & 2 ** 4 \newline Ergebnis: 16 \\ \hline
or, and, not & Boolsches Oder / Und / Nicht & (a or b) and c \\ \hline
in & Element von & 1 in [1,2,3]  \\ \hline
<, <=, >, >=, !=, == & Vergleichsoperatoren & 4 <= 5 \\ \hline
\end{tabular}
\end{table}

% ----------------------------------------------------------------
\section{Fehler- und Ausnahmebehandlung}
\label{kontrollstrukturen:section:fehlerundausnahmebehandlung}

In diesem Kapitel beschäftigen wir uns mit der Fehler- und Ausnahmebehandlung in Python.
Dabei sollte darauf geachtet werden, dass überall da, wo ein potenzieller Fehler auftreten kann, die Maßnahmen zur Fehler- und Ausnahmebehandlung angewendet werden.
Somit können wir entsprechende Syntaxfehler zur Laufzeit abfangen und geeignet behandeln, ohne das unser Programm vorzeitig durch einen Absturz beendet wird.

\subsection{Mögliche Fehlerquellen}
\label{kontrollstrukturen:section:fehlerquellen}
Die Möglichkeiten der Fehlerquellen sind vielseitig. Eine der Bekanntesten davon ist wohl ein Eingabefehler durch den Benutzer.
Dieser soll beispielsweise eine Zahl mithilfe der Tastatur eingeben, damit diese durch das Programm weiterverarbeitet werden kann.
Durch ein Vertippen des Anwenders wird ein Text in Form eines einzelnen Buchstabens anstatt einer Zahl übergeben.
Dies führt zur Laufzeit zu einem Fehler, das Programm hat eine Zahl an Stelle eines Textes erwartet.
Eine andere Fehlerquelle wäre die Division durch die Zahl Null.
Ebenso könnte der Zugriffsversuch auf eine Datei zum Bearbeiten fehlschlagen, da diese zu dem aktuellen Zeitpunkt noch nicht existiert.
\\ \\
Aus diesen genannten Ursachen ist eine Fehler- und Ausnahmebehandlung sinnvoll und sollte von einem Programmierer für einen möglichen Einsatz stets bedacht werden.

\subsection{try, except, else und finally}
\label{kontrollstrukturen:section:tryblock}


Der \lstinline$try-Block$  \randnotiz{try}wird mit dem Schlüsselwort \lstinline$try$ gefolgt von einem Doppelpunkt eingeleitet.
Anschließend wird der auszuführende Code, der einen Fehler beinhalten könnte, darin angegeben.
Mit dem Schlüsselwort\randnotiz{except} \lstinline$except$   und dem Namen der zu behandelnden Fehlerklasse wie beispielsweise \\ \lstinline$ZeroDivisionError$ kann ein entsprechender Fehler geeignet behandelt werden.
Dabei sind auch mehrere \lstinline$except$-Anweisungen mit unterschiedlichen Fehlerklassen möglich, um eine entsprechende Behandlung zu ermöglichen.
Somit kann jeder Fehler nach seiner eigenen Art und Weise nach dem Auftreten konsequent und individuell behandelt werden.
% Somit kann jdeder Fehler entsprechend individuell behandelt werden.
Auch die Erstellung von eigenen Fehlerklassen ist in Python möglich, dazu später mehr.
\\ \\
Einige wichtige und gängige Fehlerklassen sind hierbei:
\\ \\
\lstinline$"ZeroDivisonError"$: Tritt auf bei einer Division durch die Zahl null.

\lstinline$"FileNotFoundError"$: Tritt auf, wenn die zu öffnende Datei nicht gefunden werden kann.

\lstinline$"IOError"$: Tritt auf, wenn man auf eine Ressource zugreifen möchte, die momentan nicht verfügbar ist. Beispielsweise der Zugriff auf einen Drucker, der zu dem aktuellen Zeitpunkt sich in dem Status \glqq{}offline\grqq{} befindet.

\lstinline$"ValueError"$: Tritt auf, wenn ein anderer Datentyp als der erwartete Verarbeiteten werden soll.
Beispiel: Es wird eine Zahl erwartet, aber ein Text übergeben.

Darüber hinaus gibt es noch weitere wie z. B. ImportError, KeyError, MemoryError, NameError, TypeError und viele mehr, die hier im Kontext nicht weiter erläutert werden.

Im folgenden Listing wird ein Fehler provoziert, indem wir eine Division mit der Zahl Null herbeiführen.
Hierbei wird die Fehlerbehandlung mit der Klasse \lstinline$ZeroDivisonError$ abgefangen und anschließend das Programm durch die Fehlerbehandlung ordnungsgemäß beendet.
Dabei wird die nachfolgende \lstinline$else-klausel$ durch das Auftreten und Abfangen des Fehlers nicht ausgeführt.

\lstinputlisting[language=Python,
firstline=1,lastline=16]{chapters/basics/src/ExceptionHandling.py}
\label{kontrollstrukturen:lst:zerodivisonerror}

Die \lstinline$else$-Anweisung \randnotiz{else}kann im Code optional mit angegeben werden und wird nur ausgeführt,
falls es zu keiner Ausnahme in dem \lstinline$try-Block$ kommt.
Somit wird nach der Ausführung des \lstinline$try-Blocks$ auch der in \lstinline$else$ stehende Code ausgeführt, wie es das nachfolgende Listing demonstriert:

\lstinputlisting[language=Python, linerange={1-3,20-32}]{chapters/basics/src/ExceptionHandling.py}
\label{kontrollstrukturen:lst:else}


Mit der ebenfalls optionalen Angabe von \lstinline$finally$ \randnotiz{finally} lässt sich ein Codestück unter allen Umständen, ausführen.
Somit wird gewährleistet das dieser Teil des Codes ungeachtet, ob eine Ausnahme eintrifft oder nicht garantiert durchlaufen wird.
Dies kann vor allem bei dem Schließen einer Datei oder einer Datenbankverbindung sehr sinnvoll eingesetzt werden.

Bei dem folgenden Listing wird eine Datei zunächst angelegt und geöffnet.
Anschließend wird das Ergebnis in die Datei geschrieben.
Ungeachtet dessen ob im \lstinline$try-Block$ eine Fehlerbehandlung eintritt oder nicht, wird zum Schluss garantiert die \lstinline$finally$-Anweisung durchlaufen.
Damit ist die Schließung der Datei garantiert.

\lstinputlisting[language=Python, linerange={1-3,36-58}]{chapters/basics/src/ExceptionHandling.py}
\label{kontrollstrukturen:lst:finally}

Anstatt die beiden Fehlerklassen \lstinline$ZeroDivisonError$ und \lstinline$FileNotFoundError$ mit demselben Code individuell zu behandeln,
bietet es sich hier an, mehrere Ausnahmen innerhalb eines \lstinline$except$ zusammenzufassen.
Tritt nun während der Abarbeitung im \lstinline$try-Block$ einer der genannten Fehler auf, wird die Fehlerbehandlung ausgeführt.

\begin{lstlisting}[language=Python]
except (ZeroDivisionError, FileNotFoundError) as e:
print("error message: ", e)
print("Das Programm wird beendet.")
\end{lstlisting}

\subsection {raise}
\label{kontrollstrukturen:subsec:raise}

Die \lstinline$raise$-Anweisung ermöglicht uns das Generieren bzw. Auslösen einer Ausnahme. Dabei wird die Ausnahme angegeben, die ausgelöst werden soll.

\lstinputlisting[language=Python, linerange={1-3,61-70}]{chapters/basics/src/ExceptionHandling.py}
\label{kontrollstrukturen:lst:raise}

Somit ist es uns beispielsweise möglich eine \lstinline$ZeroDivisonError$ zu erzwingen, wie das folgende Beispiel demonstriert:

\lstinputlisting[language=Python, linerange={1-3,73-81}]{chapters/basics/src/ExceptionHandling.py}
\label{kontrollstrukturen:lst:raisemitaufruf}

\subsection {Selbst definierte Ausnahmen}
\label{kontrollstrukturen:subsec:selbstdefinierteeausnahmen}

Nachdem wir uns mit der \lstinline$raise$-Anweisung beschäftigt haben, widmen wir uns den selbst definierten Ausnahmen.
Diese werden in der Regel als eigenen Klassen definiert und müssen dabei von der Oberklasse \lstinline$Exception$ erben.
Das nachfolgende Listing zeigt ein entsprechendes Szenario.
Dabei wird zunächst eine eigene Klasse \lstinline$MyException$ definiert, die von Exception erbt.
Durch die \lstinline$raise$-Anweisung können wir unsere selbst definierte Ausnahme auslösen.

\lstinputlisting[language=Python, linerange={1-3,85-97}]{chapters/basics/src/ExceptionHandling.py}
\label{kontrollstrukturen:lst:eigeneaushamendefiniert}

\subsection {Zusammenfassung}
\label{kontrollstrukturen:subsec:zusammenfassungfehlerundausnahmebehandlung}

In diesem Kapitel haben wir uns ausgiebig mit der Fehler- und Ausnahmebehandlung befasst.
Zu Beginn haben wir uns einige mögliche Fehlerquellenszenarios, die durch fehlerhafte Benutzereingaben entstehen können näher angeschaut. Neben der Betrachtung der einzelnen \lstinline$try$, \lstinline$except$, \lstinline$else$, \lstinline$finally$, \lstinline$raise$ Anweisungen, haben wir uns am Ende auch mit der Implementierung von eigens definierten Ausnahmen beschäftigt.
Dabei geht aus diesem Kapitel vor allem hervor, dass ein Programmierer immer darüber nachdenken sollte, ob es in seinem Code zu einem Fehler kommen kann. Denn dies gilt es mit einer entsprechenden Fehler- und Ausnahmebehandlung abzufangen.

\uebungTutorial{ifelseAufgabe1}{KontrollstrukturenAufgabe1}

\aufgabe{exceptionhandling01}
\aufgabe{exceptionhandling02}
\aufgabe{exceptionhandling03}


