% !TeX root = ../../pythonTutorial.tex
\section{Dateien lesen und schreiben}
\label{filehandling:section:dateienlesenundschreiben}

Python bietet nativ Möglichkeiten für das Bearbeiten von Dateien.
Hierfür werden Objekte erstellt und verwendet, die eine Datei im Quellcode repräsentieren.
Mithilfe dieser, im folgenden \lstinline$fileObjects$ genannt, lässt sich der Inhalt einer Datei ändern und wird gespeichert,
sobald es im Code mit der \lstinline$close()$-Methode geschlossen wird.

\subsection{Dateitypen}
\label{filehandling:section:filetypes}

In Python werden Dateien in zwei Kategorien eingeteilt. Entweder in Text- oder Binärdateien.

Textdateien bestehen aus Zeilen, die aus einer Zeichensequenz bestehen und mit einem \glqq{}End of Line\grqq{}-Zeichen beendet werden.
Als solches kann beispielsweise ein Zeilenumbruch oder Komma dienen.

Als Binärdateien werden sämtliche Dateien interpretiert, die keine Textdateien sind.
Um diese nutzen zu können, muss der Programmierer eine Möglichkeit zur Verarbeitung bereitstellen.

In diesem Kapitel werden Beispiele anhand einer Textdatei durchgeführt.

\subsection{Open-Methode}
\label{filehandling:section:open}

Die tragenden Rolle für das Bearbeiten von Dateien in Python ist die \lstinline$open()$-Methode.
Diese erlaubt das Erstellen, Öffnen, Aktualisieren, Lesen und Schreiben einer Datei.

Mithilfe des folgenden Codes wird eine neue Datei erstellt und als \lstinline$fileObject$ geöffnet.
\lstinputlisting[language=Python, linerange={1-2,5-6}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:open}
Zum Erstellen einer neuen Datei wird als erster Parameter ein Dateiname und als zweiter der \lstinline$"x"$-Modus gewählt.
Die Datei wird am gleichen Speicherort, wie die .py-Datei erzeugt, sofern vor dem Dateinamen kein Pfad angegeben wird.
Sollte an der angegebenen Stelle bereits eine Datei mit dem gewählten Namen existieren, bleibt diese unverändert und es wird ein Fehler erzeugt.

Wird das \lstinline$fileObject$ im Code nicht mehr benötigt, wird es mit folgender Zeilen-Anweisung geschlossen:
\lstinputlisting[language=Python, linerange={1-2,7-8}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:close}
Nach einem Schließen der Datei wird der verwendete Speicherplatz freigegeben.
Das Arbeiten ist dann über das entsprechende \lstinline$fileObject$ nicht mehr möglich.

\tip{Direkt nach Ausführen der gewünschten Operationen, empfiehlt es sich, die Datei zu schließen. Auf diese Weise wird sichergestellt, dass die Datei nicht unabsichtlich bearbeitet wird.}

Für die \lstinline$open()$-Methode stehen folgende Modi zur Verfügung:

\begin{description}
    \item[x:] Erzeugen einer neuen Datei.\randnotiz{Zugriffmodus}
    Sollte bereits eine Datei mit dem gewählten Namen existieren, wird ein Fehler ausgegeben.
    \item[r:] Lesen einer Datei. 
    \item[r+:] Lese- und Schreibrechte auf einer Datei.
    \item[a:]  Hinzufügen von Inhalt am Ende der Datei.
    Erzeugt eine neue Datei, falls keine mit dem gewählten Namen an der angegebener Pfadangabe existiert.
    \item[a+:] \lstinline$"a"$ wird um das Leserecht auf der Datei ergänzt.
    \item[w:] Schreiben einer Datei.
    Überschreibt den Inhalt der Datei.
    Sollte die Datei mit dem gewählten Namen noch nicht existieren, wird eine neue erzeugt.
    \item[w+:] \lstinline$"w"$ wird um das Leserecht auf der Datei ergänzt.
    \item[t, b:] Angabe, ob die Datei als Text- \lstinline$"t"$ oder Binärdatei \lstinline$"b"$ interpretiert werden soll.
    Diese Modi können jeweils zu den anderen hinzugefügt werden. Standardmäßig wird die Datei als Text interpretiert, \lstinline$"t"$ kann hierbei weggelassen werden.
\end{description}

\lstinputlisting[language=Python, firstline=1,lastline=10]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandling.py}
\label{filehandling:lst:opentype}


\subsection{Methoden}
\label{filehandling:section:methods}

Die zuvor erstellte Datei hat noch keinen Inhalt.
Um dies zu ändern, wird die \lstinline$datei.txt$ im \lstinline$"w"$-Modus geöffnet.
Danach kann der Datei über die \lstinline$write()$-Methode wie folgt eine Textzeile hinzugefügt werden.
\lstinputlisting[language=Python, linerange={1-2,10-14}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openwrite}
Mithilfe der \lstinline$writelines()$-Methode kann die Datei mit einer List von String-Werten beschrieben werden.
\lstinputlisting[language=Python, linerange={1-2,16-24}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openwritelines}
Die Datei in dem Beispiel wurde erstellt, geöffnet, beschrieben und überschrieben.
Als nächstes soll der Inhalt aus der Datei auf der Konsole ausgegeben werden.
Hierzu wird der Modus, in dem die \lstinline$datei.txt$ geöffnet wird, auf \lstinline$"r"$ gestellt.
Die \lstinline$read()$-Methode liefert den Inhalt als String, welcher über \lstinline$print()$ ausgegeben wird.
\lstinputlisting[language=Python, linerange={1-2,26-35}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openread}
Soll eine einzelne Zeile ausgegeben werden, kann die \lstinline$readline()$-Methode verwendet werden.
Mittels eines int-Werts als Parameter kann eine Grenze festgelegt werden, die bestimmt, bis zu welcher Position die Zeile ausgelesen werden soll.
Ohne Angabe eines Parameters wird die gesamte Zeile ausgelesen.
Dies gilt sowohl für die \lstinline$read()$- als auch für die \lstinline$readline()$-Methode.

Wird der folgende Code ausgeführt, fällt auf, das die \lstinline$datei.txt$ drei
Zeilen enthält und für jede Zeile die Anweisung \lstinline$print(fileObject.readline())$ benötigt wird,
um den Inhalt vollständig auszugeben.
Folglich muss im\\
\lstinline$fileObject$ die aktuelle Leseposition gespeichert sein.
\lstinputlisting[language=Python, linerange={1-2,37-50}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openreadline}

Anstelle der Ausgabe über \lstinline$read()$ oder der mehrfachen Verwendung von \lstinline$readline()$, können wir auch über das \lstinline$fileObject$ iterieren.
In diesem Fall verwenden wir eine for-Schleife.
\lstinputlisting[language=Python, linerange={1-2,52-64}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openreadfor}
Eine weitere Alternative ist die \lstinline$readlines()$-Methode, die eine List mit den Zeilen der Datei als Inhalt liefert.
\lstinputlisting[language=Python, linerange={1-2,66-73}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openreadlines}
Wird die \lstinline$readlines()$-Methode zweimal hintereinander verwendet, erhalten wir folgende Ausgabe:
\begin{lstlisting}[language=Python]
# Ausgabe:

['Hallo Welt.\n', 'Das ist ein\n', 'Beispieltext']
[]
\end{lstlisting}

Nach dem ersten Aufruf der Methode befindet sich der Zeiger am Ende des \lstinline$fileObject$.
Somit kann bei dem zweiten Aufruf kein Inhalt mehr ausgelesen werden.
Mithilfe der \lstinline$tell()$-Methode kann die aktuelle Position des Zeigers ausgegeben werden.
Fügen wir den folgenden Code vor den \lstinline$readlines()$-Methoden ein, kann der Zeiger verfolgt werden.
\lstinputlisting[language=Python, linerange={1-2,75-88}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:opentell}
Soll die Ausgabe beider Lists identisch sein, muss der Zeiger an den Anfang zurückgesetzt werden.
In Python existiert für diesen Zweck die \lstinline$seek()$-Methode.
Wird der Zeiger direkt nach der ersten Verwendung der\\
\lstinline$readlines()$-Methode auf die Position \lstinline$0$ zurückgesetzt, erhalten wir die gewünschte Ausgabe.
\lstinputlisting[language=Python, linerange={1-2,90-104}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openseek}

\subsection{With-Statement}
\label{filehandling:section:withstatement}

Bisher mussten wir in dem Code-Beispiel die \lstinline$open()$-Methode verwenden und darauf achten,
dass das \lstinline$fileObject$ mit \lstinline$close()$ nach Gebrauch wieder geschlossen wird.

Alternativ kann das \lstinline$with$-Statement genutzt werden.
So wird die Datei nach Verwendung automatisch geschlossen, ohne die explizite Angabe von\\
\lstinline$close()$.
Der Code zum Auslesen der datei.txt sieht wie folgt aus:
\lstinputlisting[language=Python, linerange={1-2,106-114}]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingReadWrite.py}
\label{filehandling:lst:openwithstatement}

\subsection{Attribute}
\label{filehandling:section:attributes}

Jedes \lstinline$fileObject$ besitzt Attribute, die Auskunft über das jeweilige Objekt angeben.
\begin{description}
    \item[closed:] Gibt Auskunft darüber, ob die Datei geschlossen wurde. Als Rückgabe erhalten wir einen boolean-Wert.
    \item[mode:] Liefert den Zugriffsmodus auf die Datei als String zurück.
    \item[name:] Liefert den Namen der geöffneten Datei als String zurück.
\end{description}

\lstinputlisting[language=Python, firstline=0,lastline=13]{chapters/inputOutput/src/dateienLesenUndSchreiben/FileHandlingAttributes.py}
\label{filehandling:lst:openattributes}
